### Python ###


# 문자열 만들기 #
""" 111 """ or ''' 111 '''

# 문자열 포메팅(f-string)
f'문자열 {변수} 문자열'
print(f"내 포트폴리오 최종 수익률: {(my_wealth.iloc[-1] - 1) * 100:.2f}%")
:.2f : 소수 둘째 자리만 보여달라.

# 딕셔너리 #
var['key3']=3, print(var)
{'keys':3}
var.keys() / var.values()

# 집합 #
특징 : 중복 허용하지 않음, 순서가 없음.
s1.union(s2) / s1.intersection(2) / s1.difference(s2)

# 오류 처리방법(try-except) #
number = [1,2,3,"4",5]
for i in number:
    try:
        print(i**2)
    except:
        print('Error at:'+i)

# 함수 정의하기(def-return) #
def sqrt(x):
    res=x**(1/2)
    return res

# 람다 함수(lambda 매개변수1, 매개변수2: statement) #
divide_lam=lambda x, n:x/n

# 데이터프레임 열, 행 선택하기 #
df.col1 / df.loc['index1'] / df.iloc[0]

# csv와 Excel 파일 불러오기 #
data_csv = pd.read_csv(파일경로 C:\Users~ 혹은 파일명'https://~)
data_excel = pd.read_excel(파일경로 혹은 파일명, sheet_name='kospi')

# 데이터프레임 csv 혹은 excel 파일로 저장하기 #
data_csv.to_csv('data.csv')
data_excel.to_excel('data.xlsx')

# 데이터프레임 사용함수 #
df['sex'].value_counts()
df['survived'].mean() : 평균 / .min / .max / .median()

# 인덱스 다루기 # 
df.set_index('열', inplace = True) : '열'을 기준으로 인덱스 변경
df.sort_index('행', inplace=True) : 오름차순
df.sort_index('행', inplace=True,ascending=False) : 내림차순
df.sort_values('열') : 열 값 기준 오름차순
df.reset_index(inplace=True) : 인덱스 원상복구
df.rank() : 각 행에 등수를 매긴다.(sort는 정렬만)

# 필터링 #
filter_bool = (df['열'] == 4)&(df['열2'] >= 100)
df.loc[filter_bool, ]

filter_isin = df['name'].isin(['열1'],['열2'],['열3']) : 원하는 열 필터링

# 데이터프레임 결합 #
pd.concat([df1,df2,df3]) : 행 기준 결합
pd.concat([df1,df4], axis=1) : 열 기준 결합
pd.concat([df1,df4], axis=1, join="inner") : 열 기준 교집합 결합

df1.join(df2) : df1기준 df2 결합

# 피벗 #
df.pivot_table(index='열1', columns='열2', values='열3', aggfunc='mean') : 열1, 열2를 기준으로 열3의 평균을 구한다

# 행, 열 전환 #
df.stack() : 열 인덱스를 행 인덱스로 변환
df.unstack() : 행 인덱스를 열 인덱스로 변환

# 그룹화 #
df.groupby(['열1'])
df.groupby(['열1'])['열2].mean()

# 불니언 인덱싱 #
Pandas의 대괄호는 True인 행만 남기고 False 행은 버리라는 약속이 존재.
df[조건] = df자료행에서 조건에 맞는 행만 남겨

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 데이터 시각화(p.110) ###
import seaborn as sns : 고급시각화
import matplotlib.pyplot as plt : bar, scatter, hist, plot

# matpltlib 패키지 이용한 시각화 #
plt.scatter(x축 지정, y축 지정)
plt.show()

plt.rc('font', family='Malgun Gothic') : 한글 사용 가능 폰트 지정

fig, axes = plt.subplts(2,1,figsize=(10,6)) : 행 2개 열 1개인 다중 그래프 생성
axes[0].scatter( , )
axes[0].set_xlabel( )
axes[0].set_ylabel( )
axes[0].set_title( )
axes[1].hist( ,bins=30) : bins는 히스토그램 간격
axes[1].set_xlabel( )
axes[1].set_ylabel( )
axes[1].set_title( )
plt.subplots_adjust(left= ,right= ,bottom= ,top = ,wspace= ,hspace=) : 여백 간격조정

# 그리기 과정 #
plt.plot(데이터, label='', color='blue', linestyle='--')
plt.title('Backtest Result: My Portfolio vs KOSPI') # 제목 달기
plt.legend()  # 범례(이름표) 표시하기 (label에 적은 내용이 나옴)
plt.grid(True) # 모눈종이 격자 표시 (그래프 보기 편하게)
plt.show()    # 최종적으로 화면에 출력! 짠!

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### SQL ### (데이터 보관, 검색, 확인용도)

# 열 추가 및 삭제 #
alter table goods add column goods_name varchar(100); : goods_name 열 추가
alter table goods drop column goods_name : goods_name 열 삭제

# 열 선택 #
select 열1, 열2 : 열 자리에 * 입력 시 전체 선택
from 테이블 이름;
select 열1 as 별명 : 열1 이름 별명으로 수정
select '값' as 추가열 : 추가열을 생성하고 '값' 입력

# 중복 제거 #
select distinct 열1 : 열1 내 중복된 값 삭제

# 조건 생성(where) #
select goods_name
from goods
where goods_classify ='의류'
where buy_price in (320,500,5000); : buy_price가 320 or 500 or 5000인 데이터 추출

# 집약함수 (count, sum, avg) #
select count(열1)
from goods; : 열1의 개수 반환

# 그룹화 (group by) #
select 열1, count(*)
from 테이블1
group by 열2; : 열2를 기준으로 열1의 값을 세라

select buy_price, count(*)
from goods
where goods_classify ='의류'
group by buy_price; : 상품분류가 의류인 애들만 모아서 구매 가격으로 분류하고 가격의 개수 데이터 추출

select goods_classify, avg(sell_price)
from goods
group by goods_classify
having avg(sell_price) >= 2500; : 상품분류로 그룹화하고, 판매 가격 평균을 구한 다음, 판매가격 평균이 2500보다 크거나 같은 데이터 추출

# 정렬 #
select *
from goods
order by sell_price; : 판매가격을 기준으로 오름차순

select *
from goods
order by sell_price desc; : 판매가격을 기준으로 내림차순

# 함수 #
abs : 절대값
mod : 나눈 후 나머지 반환
round : 반올림
std : 표준편차
var : 분산
d1.cov(d2) : 두 데이터(d1, d2) 사이의 공분산

# 데이터 검색 #
select *
from 테이블
where strcol like 'ddd%'; : 전방일치 / where strcol like '$ddd%'; : 중간일치 / where strcol like '%ddd'; : 후방일치 / where 열1 between 100 and 1000; : 사잇값

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 자주 쓰이는 함수 ###
replace(‘전’, ‘후’) : 전, 후 데이터 교체
datetime.dateime.now() = a / a.date() / a.time() / a.strftime(‘%Y-%m-%d’) : 날짜, 시간 / df['열1] = pd.to_datetime(df['pickup'])
time.sleep(1) : 실행 속도 조절
df.shape : 데이터프레임 크기 반환 (행, 열)
df.info() : 데이터프레임 기본정보 확인
value_counts(normalize=True).sort_index() : 비중 계산 및 인덱스 정렬
df.dropna() : 데이터에 결측치 존재 시 행 삭제
df.dropna(axis=1) : 데이터에 결측치 존재 시 열 삭제
df.dropna(axis=1, thresh=300) : 결측치가 300개 이상 갖는 열을 삭제
df_2['열'].fillna(대체값, inplace = True) : 해당 열 결측치를 대체값으로 변경하며 원본객체가 변경됨
df['열'].unique() : 해당열의 고유값들 반환
df.to_frame() : 시리즈를 데이터프레임으로 변경
리스트 컴프리헨션 : 새로운_리스트 = [변형할 형태 for 임시변수 in 원본 데이터]

## %whos ##
내가 정의한 이름 확

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 퀀트 전략 ###
## 개념 ##
# 베타 #
베타값 확인 : 전체 증시의 증감에 얼마나 영향을 받는 주식인지 판단하여 시장 흐름에 맞게 베타값이 높고 낮은 주식 선

@@ -190,46 +191,36 @@
저평가된 가치주를 찾아 포트폴리오 구성하기(가치주의 수익률이 더 높은 것의 증명과 가치주 선별법)

# 모멘텀 #
주가가 꾸준히 상승하는 기업의 주식이 모템텀 효과에 의해 지속적으로 상승하게 된다. 단기에 주식이 상승한 기업의 주가는 상승분이 전자에 비해 낮다.
주로 1년 기간을 기준으로 잡는다. (252일)

# 퀄리티 #
기업의 우량성을 기준으로 삼는다. 유동자산이 풍부하여 재무 건전성이 높고 꾸준히 이익을 달성하는 기업이먀 실적의 강력한 성장 추세와 높은 자기자본이익률(ROE).
주로 돈을 얼마나 잘 버는지(ROE, ROA, 매출총이익률 등)을 가장 중요하게 여긴다.

# 마법 공식 #
상기된 둘 이상의 팩터들을 결합해 투자하는 것이 더 좋은 포트폴리오 생성이 가능하다. = 멀티팩터
통상 밸류와 퀄리티 조합을 가장 많이 사용한다.

# 이상치(최상위와 최하위) 데이터 처리 #
트림 : 이상치 데이터 삭제
윈저라이징 : 이상치 데이터 대체

## 기술 ##
# 수익률 #
data.pct_change() : 현재 값과 바로 이전 값(기본값은 1일 전)의 차이를 비율로 계
data.cumprod() : 누적 곱의 약자로, 첫 날부터 지금까지의 누적(복리) 계
data.resample('ME') : data에 있는 매일매일의 날짜를 월 단위로 묶음
data.last() : 그 달의 가장 마지막 데이터만 남

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 포트폴리오 구성 전략 ###

# 샤프지수 #
샤프지수란 포트폴리오 수익을 변동성으로 나눈 값, 위험 대비 수익률이다. 샤프지수가 높을수록 좋다.

# 최소분산 #
변동성이 최소인 포트폴리오 열 추가 및 삭제 #
alter table goods add column goods_name varchar(100); : goods_name 열 추가
alter table goods drop column goods_name : goods_name 열 삭제

# 제약조건 #
최소 투자비중 및 최대 투자비중 제약조건 설정

# 위험균형 포트폴리오 #
한계 위험기여도(MRC) : 특정 자산 비중을 한 단위 증가시켰을 때 전체 포트폴리오 위험의 증가를 나타내는 단위
위험기여도 : 특정 자산이 포트폴리오 내에서 차지하는 위험의 비중

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 트레이딩 기술적 지표(기술적 분석, 단기, 트레이딩) ###


#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 백테스팅 시뮬레이션 ###
현재 생각한 전력울 과거부터 실행했을 때 어떠한 성과가 발생하는지 테스트해보는 과정.

